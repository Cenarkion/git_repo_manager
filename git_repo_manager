#!/usr/bin/env python3

import requests
import argparse
import os
import sys
import getpass
import configparser
import stat
import subprocess

CONFIG_DIR = os.path.join(os.path.expanduser("~"), ".git_repo_manager")
CONFIG_FILE = os.path.join(CONFIG_DIR, "config.ini")

def get_github_token_from_config():
    """Reads the GitHub token from the configuration file."""
    config = configparser.ConfigParser()
    if os.path.exists(CONFIG_FILE):
        config.read(CONFIG_FILE)
        if 'github' in config and 'token' in config['github']:
            return config['github']['token']
    return None

def save_github_token_to_config(token):
    """Saves the GitHub token to the configuration file with secure permissions."""
    os.makedirs(CONFIG_DIR, exist_ok=True)
    
    config = configparser.ConfigParser()
    config['github'] = {'token': token}
    
    with open(CONFIG_FILE, 'w') as configfile:
        config.write(configfile)
    
    # Set secure permissions (read/write only for owner)
    os.chmod(CONFIG_FILE, stat.S_IRUSR | stat.S_IWUSR)
    print(f"GitHub token saved to {CONFIG_FILE} with secure permissions.")

def delete_github_repo(repo_owner, repo_name, token):
    """Deletes a GitHub repository."""
    API_URL = "https://api.github.com"
    headers = {
        "Authorization": f"token {token}",
        "Accept": "application/vnd.github.v3+json"
    }
    
    delete_url = f"{API_URL}/repos/{repo_owner}/{repo_name}"
    
    try:
        r = requests.delete(delete_url, headers=headers)
        r.raise_for_status()
        print(f"Successfully deleted repository: {repo_owner}/{repo_name}")
    except requests.exceptions.RequestException as err:
        print(f"Error deleting repository {repo_owner}/{repo_name}: {err}")
        if r.status_code == 404:
            print("Repository not found. It might have already been deleted or the name/owner is incorrect.")
        elif r.status_code == 403:
            print("Forbidden. Check if your token has the 'delete_repo' scope.")
        sys.exit(1)

def create_and_push_repo(repo_name, repo_owner, token, is_private):
    """Creates a private GitHub repository."""
    repo_url = create_github_repo(repo_name, repo_owner, token, is_private)
    if not repo_url:
        print("Failed to get repository URL after creation.")
        sys.exit(1)
    print(f"Repository '{repo_name}' created successfully. You can now add it as a remote and push your local repository:")
    print(f"  git remote add origin git@github.com:{repo_owner}/{repo_name}.git")
    print("  git push -u origin master")

def init_and_push_current_dir(repo_name, repo_owner, token, is_private):
    """Initializes a Git repository in the current directory, creates a remote GitHub repository, and pushes."""
    try:
        # Initialize Git in the current directory
        subprocess.run(["git", "init"], check=True, capture_output=True, text=True)
        print("Initialized empty Git repository in current directory.")

        # Get user.name and user.email from git config
        git_user_name = subprocess.check_output(["git", "config", "user.name"]).strip().decode()
        git_user_email = subprocess.check_output(["git", "config", "user.email"]).strip().decode()

        # Configure user.name and user.email if not already set
        if not git_user_name:
            git_user_name = input("Git user.name not found. Please enter your Git user.name: ")
            subprocess.run(["git", "config", "user.name", git_user_name], check=True)
        if not git_user_email:
            git_user_email = input("Git user.email not found. Please enter your Git user.email: ")
            subprocess.run(["git", "config", "user.email", git_user_email], check=True)

        # Add all files and make an initial commit
        subprocess.run(["git", "add", "."], check=True, capture_output=True, text=True)
        subprocess.run(["git", "commit", "-m", "Initial commit from git_repo_manager"], check=True, capture_output=True, text=True)
        print("Initial commit created.")

        # Create remote repository on GitHub
        repo_url = create_github_repo(repo_name, repo_owner, token, is_private)
        if not repo_url:
            print("Failed to get repository URL after creation.")
            sys.exit(1)

        # Add remote origin and push
        subprocess.run(["git", "remote", "add", "origin", f"git@github.com:{repo_owner}/{repo_name}.git"], check=True, capture_output=True, text=True)
        subprocess.run(["git", "branch", "-M", "main"], check=True, capture_output=True, text=True) # Ensure branch is 'main'
        subprocess.run(["git", "push", "-u", "origin", "main"], check=True, capture_output=True, text=True)
        print(f"Successfully pushed current directory to {repo_owner}/{repo_name} on GitHub.")

    except subprocess.CalledProcessError as e:
        print(f"Error during git operations: {e}")
        print(f"Stderr: {e.stderr}")
        sys.exit(1)
    except FileNotFoundError as e:
        print(f"Error: {e}. Make sure 'git' is installed and in your PATH.")
        sys.exit(1)

def main():
    parser = argparse.ArgumentParser(description="Manage GitHub repositories (delete or create/push).")
    parser.add_argument("--repos", "-r", nargs='+', help="List of repository names to delete.")
    parser.add_argument("--owner", "-o", help="The GitHub username or organization that owns the repositories. If not provided, it will try to get it from git config user.name.")
    parser.add_argument("--create-and-push", "-c", metavar="REPO_NAME", help="Create a new private GitHub repository with the given name and push the current local repository to it.")
    parser.add_argument("--public", "-P", action="store_true", help="Make the newly created repository public (default is private).")
    parser.add_argument("--init-and-push", "-g", metavar="REPO_NAME", help="Initialize a Git repository in the current directory, create a remote GitHub repository, and push the current directory's content.")
    args = parser.parse_args()

    token = os.environ.get("GITHUB_TOKEN")
    if not token:
        token = get_github_token_from_config()

    if not token:
        try:
            token = getpass.getpass("GitHub token not found. Please enter your GitHub personal access token: ")
            save_choice = input(f"Save token to {CONFIG_FILE} for future use? (y/N): ").lower()
            if save_choice == 'y':
                save_github_token_to_config(token)
        except getpass.GetPassWarning:
            print("Could not read password securely.")
            token = input("GitHub token not found. Please enter your GitHub personal access token: ")
            save_choice = input(f"Save token to {CONFIG_FILE} for future use? (y/N): ").lower()
            if save_choice == 'y':
                save_github_token_to_config(token)

    if not token:
        print(f"GitHub token not provided. Please set the GITHUB_TOKEN environment variable, provide it in {CONFIG_FILE}, or enter the token when prompted.")
        sys.exit(1)

    if args.create_and_push and args.init_and_push:
        print("Error: Cannot use --create-and-push and --init-and-push together.")
        sys.exit(1)
    if args.repos and (args.create_and_push or args.init_and_push):
        print("Error: Cannot use --repos with --create-and-push or --init-and-push.")
        sys.exit(1)

    if args.create_and_push:
        repo_owner = args.owner
        if not repo_owner:
            try:
                repo_owner = subprocess.check_output(["git", "config", "user.name"]).strip().decode()
            except (subprocess.CalledProcessError, FileNotFoundError):
                print("Repository owner not provided and could not be found in git config. Please use the --owner flag or set it in your git config (git config --global user.name <username>).")
                sys.exit(1)
        create_and_push_repo(args.create_and_push, repo_owner, token, not args.public)
    elif args.init_and_push:
        repo_owner = args.owner
        if not repo_owner:
            try:
                repo_owner = subprocess.check_output(["git", "config", "user.name"]).strip().decode()
            except (subprocess.CalledProcessError, FileNotFoundError):
                print("Repository owner not provided and could not be found in git config. Please use the --owner flag or set it in your git config (git config --global user.name <username>).")
                sys.exit(1)
        init_and_push_current_dir(args.init_and_push, repo_owner, token, not args.public)
    elif args.repos:
        repo_owner = args.owner
        if not repo_owner:
            try:
                repo_owner = subprocess.check_output(["git", "config", "user.name"]).strip().decode()
            except (subprocess.CalledProcessError, FileNotFoundError):
                print("Repository owner not provided and could not be found in git config. Please use the --owner flag or set it in your git config (git config --global user.name <username>).")
                sys.exit(1)

        print(f"Attempting to delete repositories for owner: {repo_owner}")
        for repo_name in args.repos:
            confirm = input(f"Are you sure you want to delete '{repo_owner}/{repo_name}'? This action cannot be undone. Type 'yes' to confirm: ")
            if confirm.lower() == 'yes':
                delete_github_repo(repo_owner, repo_name, token)
            else:
                print(f"Skipping deletion of {repo_owner}/{repo_name}.")
    else:
        parser.print_help()
        sys.exit(1)

def create_github_repo(repo_name, repo_owner, token, is_private):
    """Creates a private GitHub repository."""
    API_URL = "https://api.github.com"
    headers = {
        "Authorization": f"token {token}",
        "Accept": "application/vnd.github.v3+json"
    }
    
    # Get authenticated user's login to differentiate between user and organization
    try:
        user_response = requests.get(f"{API_URL}/user", headers=headers)
        user_response.raise_for_status()
        authenticated_user_login = user_response.json()["login"]
    except requests.exceptions.RequestException as err:
        print(f"Error getting authenticated user: {err}")
        sys.exit(1)

    if repo_owner == authenticated_user_login:
        create_url = f"{API_URL}/user/repos"
    else:
        create_url = f"{API_URL}/orgs/{repo_owner}/repos"
    
    data = {
        "name": repo_name,
        "private": is_private,
        "description": "A Python script for managing GitHub repositories."
    }

    try:
        r = requests.post(create_url, headers=headers, json=data)
        r.raise_for_status()
        print(f"Successfully created private repository: {repo_owner}/{repo_name}")
        return r.json()["clone_url"]
    except requests.exceptions.RequestException as err:
        print(f"Error creating repository {repo_name}: {err}")
        if r.status_code == 422:
            print("Repository with this name already exists or invalid name.")
        elif r.status_code == 403:
            print("Forbidden. Check if your token has the 'repo' scope or if you have permissions for the organization.")
        sys.exit(1)

if __name__ == "__main__":
    main()
